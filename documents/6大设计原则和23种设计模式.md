# 1. 前言
### 1.1 面向对象的好处
面向对象的一个伟大的应用例子是**活字印刷术**。一篇文章印错了字，只需改错的字，而无需重新刻模板，就是**可维护**。印错的那个字的模块还可以用来印其他文章，就是**可复用**。文章加字只需另刻字加入，就是**可扩展**。活字可以横着排列印刷文章，也可竖着、斜着排列印刷文章，就是**灵活性好**。

###1.2 面向对象的特性
面向对象有三大特性，**封装**、**继承**和**多态**。**封装**是指将对象的实现细节隐藏起来，只通过一些公共方法来暴露对象的功能。**继承**是实现代码复用的有效手段，当子类继承父类后将直接拥有父类的属性和方法。**多态**是父类类型可实例化为子类类型对象，拥有子类的行为特征，这会导致同一个类型的对象在执行相同的方法时可表现出不同的行为特征。
例如
```
Animal dog = new Dog();
dog.talk(); //“汪汪汪”
Animal cat = new Cat();
cat.talk(); //“喵喵喵”
```
Dog和Cat都继承了Animal类，变量dog和cat都是Animal类型，但它们调用talk()方法时打印出的字符串却不同。
# 2. 设计原则
设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。

### 2.1 单一职责原则
单一职责原则（SRP）：是指一个类只应该有一个引起它变化的原因。
怎么判断一个类只有一个职责呢？通常一个类的可能的职责有这几种：
参考[Object Design: Roles, Responsibilies, and Collaborations](http://www.amazon.com/Object-Design-Roles-Responsibilities-Collaborations/dp/0201379430)一书提出了如下Role Stereotypes来区分职责：

* Information holder – 存储对象并提供对象信息给其它对象。
* Structurer – 维护对象和信息之间的关系
* Service provider – 处理工作并提供服务给其它对象
* Controller – 控制决策一系列任务处理
* Coordinator – 不做任何决策处理工作，只是委托工作到其它对象上
* Interfacer – 在系统的各个部分转化信息（或请求）

### 2.2 接口隔离原则
接口隔离原则(ISP)：客户端不应该依赖它不需要的接口，多用组合,少用继承

### 2.3 依赖倒置原则
依赖倒置原则(DIP)： 提高灵活性,高层不依赖低层,底层也不依赖搞错，两个都应该依赖于抽象。抽象不应该依赖细节，细节应该依赖抽象。

也就是软件系统应该易插拔，替换掉某个模块不影响其他模块的运行。就像修电脑一样，内存条坏了换内存条，屏幕坏了换屏幕，硬盘坏了换硬盘。。。因为这些模块对外的接口是固定的，更换模块内部的实现，对别的模块来说没有任何影响。所以依赖倒置就是要针对接口编程，而不是针对实现编程。

### 2.4 里氏替换原则
里氏替换原则(LSP)：子类必须能够替换他们的父类，也就是当软件使用父类时，应察觉不出父类和任何子类的区别。正是有了里氏替换原则，才使得开闭原则成为可能。

### 2.5 迪米特法则
迪米特法则(LOD)：类间解耦，类之间联系尽可能少
如果两个类之间不是必须要彼此通信，那么这两个类就不要发生直接的相互作用。如果其中的一个类A需要调用另一个类B中的某个方法，可通过第三者来转发。例如可以把这个方法写到一个公共类中，让类A来调用公共类的方法，而不是让类A直接调用类B的方法。
类之间的耦合越弱就越利于复用，因为一个类被修改就不会影响另一个类。
例如外观模式。

### 2.6 开闭原则
开闭原则(OCP)： 对扩展是开放的,对修改是封闭的。
即类、模块、函数等应尽量不修改原有的代码，但可以扩展新的，以应对变化的需求但又不影响原有功能。面对新需求，程序的改动应是通过增加新代码实现的，而不是修改旧代码。
但类不可能做到完全封闭，因此应提前预测可能发生的变化，或在发生小变化时，及时抽象出变化的部分隔离出来，以应对更大的变化。
但抽象地太多也是过犹不及，应只针对频繁变化的部分构造抽象。

###2.7 合成(Composite)/聚合(Aggregation)复用原则（CARP）
尽量使用合成/聚合，尽量不使用类继承。
合成是强拥有关系，严格地体现了部分和整体的关系，部分和整体的生命周期一样。例如翅膀与大雁。就是让原子类作为原父类的一个属性，使用不同的子类时，选择注入即可。
聚合是弱拥有关系，体现的是A对象可以包含B对象，但B对象不一定是A对象的一部分。例如大雁与雁群。
对象的继承关系是在编译时就确定好了，无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密地依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或用新的更适合的类替换。这种依赖关系限制了灵活性，并最终限制了可复用性。
# 3. 设计模式
设计模式前人总结出来的经验，是对上述七种设计原则的典型应用。
### 3.1 创建型模式
在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。

创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。

创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。

类创建型包含3种工厂模式：**简单工厂模式**、**工厂方法模式**和**抽象工厂模式**。

对象创建型包含3种设计模式：**建造者模式**、**原型模式**和**单例模式**。
### 3.2 结构型模式
结构型模式主要是用于处理类或者对象的组合，它描述了如何来类或者对象更好的组合起来，是从程序的结构上来解决模块之间的耦合问题。

结构型模式主要包括：**外观模式**、**装饰模式**、**代理模式**、**适配器模式**、**组合模式**、**桥接模式**、**享元模式**这个7个模式。

### 3.3 行为型模式
行为型模式主要是用于描述类或者对象是怎样交互和怎样分配职责的。它涉及到算法和对象间的职责分配，不仅描述对象或者类的模式，还描述了他们之间的通信方式，它将你的注意力从控制流转移到了对象间的关系上来。行为型类模式采用继承机制在类间分派行为，而行为型对象模式使用对象复合而不是继承。

行为型模式主要包括11种设计模式：**策略模式**、**状态模式**、**职责链模式**、**模板方法模式**、**备忘录模式**、**观察者模式**、**迭代器模式**、**命令模式**、**中介者模式**、**解释器模式**、**访问者模式**。
设计模式的例子代码地址：https://github.com/buptpxy/cleanCode.git